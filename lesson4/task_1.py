# Задание - 1. Анализируется задача 4 из урока 2:
# Найти сумму n элементов следующего ряда чисел: 1, -0.5, 0.25, -0.125,…
# Количество элементов (n) вводится с клавиатуры.

# распишем последовательность и обозначим ее члены как k1, k2, kx..
# 1/(2^0) - 1/(2^1) + 1/(2^2) - 1/(2^3) + 1/(2^4)...

import timeit
import cProfile

# вариант 1, рекурсия


def rec(n):
    if n == 1:
        return 1
    elif n % 2 == 0:
        return rec(n - 1) - 1 / (2 ** (n - 1))
    else:
        return rec(n - 1) + 1 / (2 ** (n - 1))

# timeit:
# 0.010762399999999998 = 100
# 0.026884399999999996 = 200
# 0.0.05890839999999999 = 400
# 0.1495291 = 800
# cProfile:
# 100/1    0.000    0.000    0.000    0.000 task_1.py:14(rec) = 100
# 200/1    0.000    0.000    0.000    0.000 task_1.py:14(rec) = 200
# 400/1    0.001    0.000    0.001    0.001 task_1.py:14(rec) = 400
# 800/1    0.002    0.000    0.002    0.002 task_1.py:14(rec) = 800

# вариант 2, рекурсия и мемоизация


def rec_dict(n):
    seq_dict = {1: 1, 2: 0.5, 3: 0.75}  # суммы для n = 1, 2, 3

    def _rec_dict(n):
        if n in seq_dict:
            return seq_dict[n]
        elif n % 2 == 0:
            seq_dict[n] = _rec_dict(n - 1) - 1 / (2 ** (n - 1))
        else:
            seq_dict[n] = _rec_dict(n - 1) + 1 / (2 ** (n - 1))
        return seq_dict[n]
    return _rec_dict(n)

# timeit:
# 0.012718100000000003 = 100
# 0.0305496 = 200
# 0.0693725 = 400
# 0.1666272 = 800
# cProfile:
# 98/1    0.000    0.000    0.000    0.000 task_1.py:40(_rec_dict) = 100
# 198/1    0.001    0.000    0.001    0.001 task_1.py:40(_rec_dict) = 200
# 398/1    0.001    0.000    0.001    0.001 task_1.py:40(_rec_dict) = 400
# 798/1    0.003    0.000    0.003    0.003 task_1.py:40(_rec_dict) = 800

# вариант 3, цикл


def loop_func(n):
    res = 0
    for i in range(n):
        if i % 2 == 0:
            res += 1 / (2 ** i)
        else:
            res -= 1 / (2 ** i)
    return res

# timeit:
# 0.008839799999999995 = 100
# 0.0219072 = 200
# 0.048470200000000005 = 400
# 0.1235059 = 800
# cProfile:
# 1    0.000    0.000    0.000    0.000 task_1.py:64(loop_func) = 100
# 1    0.000    0.000    0.000    0.000 task_1.py:64(loop_func) = 200
# 1    0.001    0.001    0.001    0.001 task_1.py:64(loop_func) = 400
# 1    0.001    0.001    0.001    0.001 task_1.py:64(loop_func) = 800

# функция для проверки работы функций rec(n), rec_dict(n), loop_func(n)


def test_func(func):
    lst = [1, 0.5, 0.75, 0.625, 0.6875]   # суммы элементов ряда до n = 5
    for i, item in enumerate(lst):
        assert item == func(i + 1)
        print(f"{i} Test OK")

# test_func(rec)
# test_func(rec_dict)
# test_func(loop_func)

# анализируем скорость алгоритма с использованием timeit:
# вместо строки s подставляем подставляется тело исследуемой функции
# и ее вызов с тестируемым значением

s = """
def loop_func(n):
    res = 0
    for i in range(n):
        if i % 2 == 0:
            res += 1 / (2 ** i)
        else:
            res -= 1 / (2 ** i)
    return res
loop_func(800)
"""
print(timeit.timeit(s, number=100))

# анализируем скорость алгоритма с использованием cProfile:
# вызываемый параметр - исследуемая функция, в которую передается иссл. значение

cProfile.run('loop_func(800)')

# Общий вывод: все алгоритмы имеют сложность O(n) (зависимость линейная, O(2.5*n) ~ O (n)).
# Быстрее всех выполняется алгоритм с использованием цикла, это показывают собранные статистические данные
# (сделано по 4 замера для каждого алгоритма)
# о времени выполнения алгоритмов с ипользованием timeit() и cProfile().
# Обусловлено это тем, что рекурсивные алгоритмы складывают данные на стек и тратят время на доступ к этим данным.
# Рекурсия с ипользованием мемоизации работает немного медленнее обычной рекурсии, т.к. использует словарь для
# решения задачи и тратит время на запись и чтение данных из словаря.
